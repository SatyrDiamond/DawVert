import mmap
import struct
from . events import *
from typing import List
from os import SEEK_CUR
from dataclasses import dataclass

# A brief description of the MIDI specification:
# - http://www.somascape.org/midi/tech/spec.html
# A brief description of the MIDI File specification:
# - http://www.somascape.org/midi/tech/mfile.html
# A MIDI Binary Template:
# - https://www.sweetscape.com/010editor/repository/files/MIDI.bt
# A description of Running Status:
# - http://midi.teragonaudio.com/tech/midispec/run.htm

metaEventByType = {
	0x00 : SequenceNumberEvent,
	0x01 : TextEvent,
	0x02 : CopyrightEvent,
	0x03 : TrackNameEvent,
	0x04 : InstrumentNameEvent,
	0x05 : LyricEvent,
	0x06 : MarkerEvent,
	0x07 : CuePointEvent,
	0x08 : ProgramNameEvent,
	0x09 : DeviceNameEvent,
	0x20 : MidiChannelPrefixEvent,
	0x21 : MidiPortEvent,
	0x2F : EndOfTrackEvent,
	0x51 : TempoEvent,
	0x54 : SmpteOffsetEvent,
	0x58 : TimeSignatureEvent,
	0x59 : KeySignatureEvent,
	0x7F : SequencerEvent,
}

channelEventByStatus = {
	0x80 : NoteOffEvent,
	0x90 : NoteOnEvent,
	0xA0 : NotePressureEvent,
	0xB0 : ControllerEvent,
	0xC0 : ProgramEvent,
	0xD0 : ChannelPressureEvent,
	0xE0 : PitchBendEvent,
}

def unpackVLQ(memoryMap):
	total = 0
	while True:
		char = struct.unpack("B", memoryMap.read(1))[0]
		total = (total << 7) + (char & 0x7F)
		if not char & 0x80: break
	return total

def parseChannelEvent(deltaTime, status, memoryMap):
	channel = status & 0xF
	eventClass = channelEventByStatus[status & 0xF0]
	event = eventClass.fromMemoryMap(deltaTime, channel, memoryMap)
	if isinstance(event, NoteOnEvent) and event.velocity == 0:
		return NoteOffEvent(deltaTime, channel, event.note, 0)
	return event

def parseMetaEvent(deltaTime, memoryMap):
	eventType = struct.unpack("B", memoryMap.read(1))[0]
	length = unpackVLQ(memoryMap)
	eventClass = metaEventByType[eventType]
	event = eventClass.fromMemoryMap(deltaTime, length, memoryMap)
	return event

def parseSysExEvent(deltaTime, status, memoryMap):
	length = unpackVLQ(memoryMap)
	if status == 0xF0:
		return SysExEvent.fromMemoryMap(deltaTime, length, memoryMap)
	elif status == 0xF7:
		return EscapeSequenceEvent.fromMemoryMap(deltaTime, length, memoryMap)

def parseEvent(memoryMap, parseState):
	deltaTime = unpackVLQ(memoryMap)
	status = struct.unpack("B", memoryMap.read(1))[0]
	
	if status & 0x80: parseState.runningStatus = status
	else: memoryMap.seek(-1, SEEK_CUR)

	runningStatus = parseState.runningStatus
	if runningStatus == 0xFF:
		return parseMetaEvent(deltaTime, memoryMap)
	elif runningStatus == 0xF0 or runningStatus == 0xF7:
		return parseSysExEvent(deltaTime, runningStatus, memoryMap)
	elif runningStatus >= 0x80:
		return parseChannelEvent(deltaTime, runningStatus, memoryMap)

@dataclass
class MidiParseState:
	runningStatus: int = 0

def parseEvents(memoryMap):
	events = []
	parseState = MidiParseState()
	while True:
		event = parseEvent(memoryMap, parseState)
		events.append(event)
		if isinstance(event, EndOfTrackEvent): break
	return events

def parseTrackHeader(memoryMap):
	identifier = memoryMap.read(4).decode('ascii')
	chunkLength = struct.unpack(">I", memoryMap.read(4))[0]
	return chunkLength

@dataclass
class MidiTrack:
	events: List

	@classmethod
	def fromMemoryMap(cls, memoryMap):
		chunkLength = parseTrackHeader(memoryMap)
		events = parseEvents(memoryMap)
		return cls(events)

def parseHeader(memoryMap):
	identifier = memoryMap.read(4).decode('ascii')
	chunkLength = struct.unpack(">I", memoryMap.read(4))[0]
	midiFormat = struct.unpack(">H", memoryMap.read(2))[0]
	tracksCount = struct.unpack(">H", memoryMap.read(2))[0]
	ppqn = struct.unpack(">H", memoryMap.read(2))[0]
	return midiFormat, tracksCount, ppqn

def parseTracks(memoryMap, tracksCount):
	return [MidiTrack.fromMemoryMap(memoryMap) for i in range(tracksCount)]

@dataclass
class MidiFile:
	midiFormat: int
	ppqn: int
	tracks: List[MidiTrack]

	@classmethod
	def fromFile(cls, filePath):
		with open(filePath, "rb") as f:
			memoryMap = mmap.mmap(f.fileno(), 0, access = mmap.ACCESS_READ)
			midiFormat, tracksCount, ppqn = parseHeader(memoryMap)
			tracks = parseTracks(memoryMap, tracksCount)
			memoryMap.close()
			return cls(midiFormat, ppqn, tracks)

